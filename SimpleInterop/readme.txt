Author: Tim Lindquist (Tim.Lindquist@asu.edu), ASU Polytechnic, CIDSE, SE
Version: March 2020

See http://pooh.poly.asu.edu/Mobile
See http://pooh.poly.asu.edu/Ser321

Purpose: This project shows how to communicate between programs of different
languages using Stream-Based Socket connections. Byte arrays are written/read
on each side of the protocol with the application usually handling what must be
done to provide conversion of the data (object) to/from a byte array. A very
common approach in stream-based socket programming. The application is a simple
echo server with clients. The Echo Server is constructed so that a server thread
is created and allocated to each client. This example has clients written in C++,
C#, and Java. The server and a third client are written in Java.

The second purpose of this example project is to demonstrate one approach that
can be used to run a processes in the background on either
Linux or MacOS. This allows you to start up a server on your Raspberry Pi,
then to log off of the RPi and have the server continue to run until the system
goes down, or you log in again to stop the service. The approach shown in this
project directory is preferred unless you want the service to start-
up automatically everytime the system is re-booted. If so, then use the system-specific
mechanism for creating a service. Linux uses the files in /etc/init.d as start-ups for
services.

Running the Example

Building and running the server and terminal clients is done with Ant.

To view the targets that are available in this project type ant (targets is the default
target).
1. ant
   The default target shows all targets supported, and the syntax for invoking programs
   after they are built.
   
2. To build all clients and the server:
   ant build.all

3. ant build.java creates two executable jar files in the lib directory for the Java
   server and client programs. Thus, after build.java, you could execute the server with:
   java -jar lib/echoserver.jar 8080
      or
   java -cp classes ser321.sockets.ThreadedEchoServer 8080
      or
   ant execute.server

4. after ant build.all, the C-Sharp client can be run with
   mono ./bin/EchoClient.exe localhost 8080

5. after ant build.all, the C++ client can be run with:
   ./bin/cppClient localhost "hello from C++" 8080

6. Running a program in the background, and allowing it to continue after you log off.
   To do this, you should provide execute permission to the shell script accompanying
   this example (the jar tool strips them off).
   chmod u+x background.sh
   You will find the bourne shell (/bin/sh) script background.sh in the project's
   base directory.
   This shell script will start, stop, or restart a server when you execute it.
   When you use it to start a server, use the command:
     ./background.sh start java -jar lib/echoserver.jar 8080
   It will start the server and record the following information in the log directory.
      log/pid.txt  the proces id of the new process. This is used by the script
          should you wish to stop the server with:
          ./background.sh stop
      log/command.txt   contains the command used to start the server. This is used
          by the script should you wish to start it again or to restart it, such as
          ./background.sh restart
      log/log.txt   contains all of the output generated by the server (prints).
      log/error.txt   contains all of the error output from the server.

   When starting a server, the script assigns the standard
   output, error, and input streams (stdin, stderr, and stdout) to files. Run:
   ./background.sh start java -jar lib/echoserver.jar 8080
  
   After executing this command script, the server will run in the background until you
   kill it manually or with the script. To see its status, and get the process id of a
   program you are running, use the ps command:
   ps -f
   which will show you a listing of your active programs. The process id (PID) of each
   running program will be shown, and the command that started it is also shown.
   To terminate a running program, you can use:
   kill -9 pid
   the -9 is a signal to the process indicating it should not ignore the kill.

end

